1.drawcall
Drawcall影响的是CPU的效率。因为draw call是CPU调用图形接口在屏幕上绘制对应的东西
解决：・ 图集（但要注意渲染顺序）见网络
          ・ Static Batching（静态批处理）比动态批次更有效，但是会占用更多内存，更少CPU（物件是静态的，不移动，不旋转也不缩放的）
          ・ Dynamic Batching（动态批次） 当物件使用相同的材质，并且满足一定的条件时，Unity会自动合并物件来减少draw call。Dynamic batching 是自动做的，不需要教你做其他的事情
          注意：接收实时阴影的物件不会batch
2.GC
虽然GC是用来处理内存的，但的确增加的是CPU的开销。因此它的确能达到释放内存的效果，但代价更加沉重，会加重CPU的负担，因此对于GC的优化目标就是尽量少的触发GC。
GC有两种情况会触发：
         ・ 首先当然是我们的堆的内存不足时，会自动调用GC。
         ・ 程序员手动调用
所以为了达到优化CPU的目的，我们就不能频繁的触发GC。而上文也说了GC处理的是托管堆，而不是Unity3D引擎的那些资源，所以GC的优化说白了也就是代码的优化。
有以下几点是需要注意的：
        ・ 字符串连接的处理。因为将两个字符串连接的过程，其实是生成一个新的字符串的过程。而之前的旧的字符串自然而然就成为了垃圾。
          而作为引用类型的字符串，其空间是在堆上分配的，被弃置的旧的字符串的空间会被GC当做垃圾回收。
        ・ 尽量不要使用foreach，而是使用for。foreach其实会涉及到迭代器的使用，而据传说每一次循环所产生的迭代器会带来24 Bytes的垃圾。那么循环10次就是240Bytes。
        ・ 不要直接访问gameobject的tag属性。比如if (go.tag == “human”)最好换成if (go.CompareTag (“human”))。因为访问物体的tag属性会在堆上额外的分配空间。
          如果在循环中这么处理，留下的垃圾就可想而知了。
        ・ 使用“池”，以实现空间的重复利用。
3.AI逻辑实现：行为树或者状态机
        ・ 状态机（FSM）：简单将就是将游戏AI行为分为一个一个的状态，状态与状态之间的过渡通过事件的触发来形成。
        ・ 分层状态机（HFSM）：就是FSM当状态太多的时候，不好维护，于是将状态分类，抽离出来，将同类型的状态做为一个状态机，然后再做一个大的状态机，来维护这些子状态机。
        ・ 行为树（Behaviour Tree）：行为树与FSM不同，它是一种“轮询式机制”，即每次更新都会遍历树，判定逻辑是否成立，是否该继续往下执行。
4.层级细节（LOD）和MipMap
        ・ 层级细节（LOD）：准备三个相同的模型，但是这三个模型他们的三角面和顶点数都不同，这样就可以代表三种从高―中―低的层级。使用这个技术可以减少需要处理的模型顶点数目，
          降低GPU性能瓶颈的风险。根据摄像机的距离来选择不同精度的模型。缺点是占用大量内存。使用这个技术，一般是在解决运行时流畅度的问题，采用的是空间换时间的方式。
        ・ MipMap：Mipmap技术有点类似于LOD技术，但是不同的是，LOD针对的是模型资源，而Mipmap针对的纹理贴图资源。使用Mipmap后，贴图会根据摄像机距离的远近，
          选择使用不同精度的贴图。缺点是占用大量内存，优点是会优化显存，减少渲染。
5.协程
        ・ Unity3d没有多线程的概念，不过unity也给我们提供了协程和异步加载的方法。所谓协同，就是当你在StartCoroutine的函数体里处理一段代码时，利用yield语句等待执行结果，这期间不影响
          主程序的继续执行，可以协同工作。
        ・ Unity的协程系统是基于C#的一个简单而强大的接口，IEnumerator，它允许你为自己的集合类型编写枚举器。
6..asset
        ・ 在游戏开发中，经常会用到一些配置文件保存一些数据，然后项目运行中读取这些配置文件中的数据在游戏中使用。
          如：配置血条：根据角色类型（人物、动物、怪物等）配置不同的血条，包括血条大小，血条名或血条预设，血条颜色等一些简单数据。
          如：配置子弹：子弹类型（真子弹、假子弹、追踪子弹等），子弹速度，伤害数值，子弹关联的特效等。
          诸如此类的配置很多种，可创建一个可序列化的类存储数据，或者创建 XML 、JSON 文件保存数据，创建 Excel 文件，创建 TXT 文件，皆可完成需求，灵活使用这些方法保存配置数据。
          在此介绍一下使用可序列化类保存配置，并且将可序列化类保存成Unity的自定义文件（.asset）,然后配置自定义文件（.asset）。
        ・ 优点：可以保存数据类型多样（int、string、Vector3、GameObject、Transform、Texture等）如关联预设，关联图片等资源数据，
          而XML、TXT等只能保存（int、string、Vector3 等基本数据类型）。
        ・ 缺点：如果配置数据中保存了（GameObject、Texture）等资源数据，当关联的资源被删除时，配置数据将丢失，需要重新将新的资源再次关联到配置数据上。
7.UnityEditor.PrefabUtility
        ・ PrefabUtility是一个静态类，主要用于进行Prefab的相关处理。 
        ・ PrefabUtility.GetPrefabParent（）找游戏场景内的对象的prefab
        ・ PrefabUtility.FindPrefabRoot（）找prefab的prefab
8.资源管理
        ・ unity常用的资源大概有3类：
          纯资源（material，texture，shader，audio ……）这些资源不能直接拖到场景里使用。
          预置（prefab），这种资源需要实例化之后才能使用 。
          scene也是一种资源 。
          还有一些平时不太关注的：脚本对象，文本文件，unity自己内置的资源（像新建粒子时的默认材质之类的），这些也是资源。
        ・ unity管理这些资源分为两种：
          在编辑器内管理，使用 AssetDatabase 加载卸载资源。在编辑器内加载卸载资源，并不能在游戏发布时使用，它只能在编辑器内使用。但是，它加载速度快，效率高，适合在测试时使用。
          运行时管理，简单化使用 Resource，复杂化使用AssetBundle。
9.AssetBundle
        ・ AssetBundle是Unity pro提供的一种用来存储资源的文件格式，它可以存储任意一种Unity引擎能够识别的资源，如Scene、Mesh、Material、Texture、Audio、noxss等等，
          同时，AssetBundle也可以包含开发者自定义的二进制文件，只需要将自定义文件的扩展名改为.bytes，Unity就可以把它识别为TextAsset，进而就可以被打包到AssetBundle中。
          Unity引擎所能识别的资源我们称为Asset，AssetBundle就是Asset的一个集合。
        ・ AssetBundle的特点：压缩（缺省）、动态载入、本地缓存